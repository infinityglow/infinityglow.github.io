[{"title":"算法与复杂度","url":"/study/algorithm/overview/algo-ov/","content":"\n## 前言\n\n这个系列的博文会逐个介绍计算机科学里面最基础、也是最重要的一部分内容：算法(algorithm)。提到它，这可能是你最擅长的部分，亦或是你学生生涯的噩梦。不管怎么样，对于学计算机的小伙伴来讲，它始终是不可回避的一个话题。不论是学生时代的你还是已经踏上了工作的岗位，算法都会一直陪伴着你。\n\n为什么要做这个系列呢？因为网上对于这一块的内容实在是太多，甚至是太杂，而很少有把算法的知识体系整合起来形成一个系列的教学博客。于是乎想尽自己的微薄之力，让更多的人能够更好地理解算法，在未来求职的面试中不再因为它而与自己理想的公司失之交臂。\n\n我将与国内的教学方式和教学内容有所差别。形式上不再是只针对如何解决这个问题，因为只会解决问题并不代表真正理解这个问题。我将花一些篇幅着重介绍一些概念性的内容，这也是国内的教学最欠缺的部分。国内的课堂不会告诉你自然对数e与自然界生长的规律有关；学完了线性代数，你可能光学会了如何解行列式，却忽视了行列式也是有几何意义的。内容上不再按照“排序算法”、“搜索算法”等方式分类，而采用了问题解决的不同方式来划分，比如“暴力求解”、“分治法”、“动态规划”等等。当然，我也是参考了Levitin编写的教材[Introduction to The Design and Analysis of Algorithms, 3rd Edition](https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/Introduction%20to%20the%20Design%20and%20Analysis%20of%20Algorithms%20%283rd%20ed.%29%20%5BLevitin%202011-10-09%5D.pdf)。要是你觉得这本书讲得太基础，你也可以参考MIT的[《算法导论》](http://kddlab.zjgsu.edu.cn:7200/students/lipengcheng/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%88%E8%8B%B1%E6%96%87%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89.pdf)。\n\n编程语言我会采用Python，因为Python是最接近这些英文书里用于讲解的伪代码，理解起来会更加方便。对于刚入门的小白来讲，Python的简洁不会让你因为不能理解编程语言本身而最终放弃了这门课程的学习。我会把每一节的内容的完整代码都放在我的GitHub的Algorithm仓库里，方便学习后用代码真正实现它们。\n\n最后，要是讲解有任何疑问，欢迎在评论区留言。如果发现了有任何错误和表述不规范的地方，希望各位大佬轻喷，毕竟我也是第一次写博客，有错误也是在所难免的。\n\n## 总览\n\n### 介绍 (Introduction)\n\n  [1.1 什么是算法](https://infinityglow.github.io/study/algorithm/introduction/)\n\n### 基本知识 (Basic Knowledge)\n\n  [2.1 基本数据结构](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/)\n  [2.2 算法的问题类型](https://infinityglow.github.io/study/algorithm/basic-knowledge/problem-types/)\n\n### 复杂度分析 (Complexity Analysis)\n\n  [3.1 三种表示方法：O, Ω, Θ](https://infinityglow.github.io/study/algorithm/complexity-analysis/three-nonations/)\n  [3.2 复杂度分析（非递归）](https://infinityglow.github.io/study/algorithm/complexity-analysis/non-recursive/)\n  [3.3 复杂度分析（递归）](https://infinityglow.github.io/study/algorithm/complexity-analysis/recursive/)\n\n### 暴力求解 (Brute Force)\n\n  [4.1 冒泡排序与选择排序](https://infinityglow.github.io/study/algorithm/brute-force/bubble-selection-sort/)\n  [4.2 顺序查找与字符串匹配（BF）](https://infinityglow.github.io/study/algorithm/brute-force/string-matching/)\n  [4.3 图的两种遍历](https://infinityglow.github.io/study/algorithm/brute-force/graph-traversal/)\n  [4.4 最近点对与凸包问题（BF）](https://infinityglow.github.io/study/algorithm/brute-force/clo-pair-con-hull/)\n  [4.5 暴力搜索](https://infinityglow.github.io/study/algorithm/brute-force/exhaustive-search/)\n\n### 减治法（Decrease and Conquer）\n\n  [5.1 插入排序](https://infinityglow.github.io/study/algorithm/decrease-and-conquer/insertion-sort/)\n  [5.2 拓扑排序](https://infinityglow.github.io/study/algorithm/decrease-and-conquer/topo-sorting/)\n  [5.3 二分查找与二叉树](https://infinityglow.github.io/study/algorithm/decrease-and-conquer/binary-search-tree/)\n  [5.4 插值查找](https://infinityglow.github.io/study/algorithm/decrease-and-conquer/interpolation-search/)\n\n### 分治法（Divide and Conquer）\n\n  [6.1 归并排序](https://infinityglow.github.io/study/algorithm/divide-and-conquer/merge-sort/)\n  [6.2 快速排序](https://infinityglow.github.io/study/algorithm/divide-and-conquer/quick-sort/)\n  [6.3 二叉树的遍历](https://infinityglow.github.io/study/algorithm/divide-and-conquer/bt-traversal/)\n  [6.4 最近点对与凸包问题（DC）](https://infinityglow.github.io/study/algorithm/divide-and-conquer/clo-pair-con-hull/)\n\n### 变治法（Transform and Conquer）\n\n  [7.1 预排序](https://infinityglow.github.io/study/algorithm/transform-and-conquer/presorting/)\n  [7.2 霍纳法则](https://infinityglow.github.io/study/algorithm/transform-and-conquer/horners-rule)\n  [7.3 堆与堆排序](https://infinityglow.github.io/study/algorithm/transform-and-conquer/heap/)\n  [7.4 AVL树](https://infinityglow.github.io/study/algorithm/transform-and-conquer/AVL-tree/)\n  [7.5 红黑树](https://infinityglow.github.io/study/algorithm/transform-and-conquer/R&B-tree/)\n  [7.6 2-3树](https://infinityglow.github.io/study/algorithm/transform-and-conquer/two-three-tree/)\n\n### 时空权衡（Time Space Tradeoff）\n\n  [8.1 计数排序](https://infinityglow.github.io/study/algorithm/time-space-tradeoff/counting-sort/)\n  [8.2 字符串匹配（TST）](https://infinityglow.github.io/study/algorithm/time-space-tradeoff/string-matching/)\n  [8.3 哈希](https://infinityglow.github.io/study/algorithm/time-space-tradeoff/hashing/)\n\n### 动态规划（Dynamic Programming）\n\n  [9.1 关于钱的两个经典问题](https://infinityglow.github.io/study/algorithm/dynamic-programming/classic-problems/)\n  [9.2 背包问题（DP）](https://infinityglow.github.io/study/algorithm/dynamic-programming/knapsack-problem/)\n  [9.3 弗洛伊德算法](https://infinityglow.github.io/study/algorithm/dynamic-programming/Floyd-Warshall/)\n  \n### 贪心算法（Greedy Algorithm）\n\n  [10.1 普林姆算法](https://infinityglow.github.io/study/algorithm/greedy-algorithm/Prim/)\n  [10.2 克鲁斯卡尔算法](https://infinityglow.github.io/study/algorithm/greedy-algorithm/Kruskal/)\n  [10.3 迪克斯特拉算法](https://infinityglow.github.io/study/algorithm/greedy-algorithm/Dijkstra/)\n  [10.4 哈弗曼树](https://infinityglow.github.io/study/algorithm/greedy-algorithm/Huffman-tree/)\n\n### *高阶算法（Optional）\n\n  [*回溯](https://infinityglow.github.io/study/algorithm/advanced-algorithm/backtracking/)\n  [*分支限界](https://infinityglow.github.io/study/algorithm/advanced-algorithm/branch-and-bound/)\n  [*线性规划（单纯形法）](https://infinityglow.github.io/study/algorithm/advanced-algorithm/linear-programming/)\n  [*最大流问题](https://infinityglow.github.io/study/algorithm/advanced-algorithm/maximum-flow/)\n  [*匈牙利算法](https://infinityglow.github.io/study/algorithm/advanced-algorithm/hungarian-algorithm/)\n  [*千禧问题：P=NP?](https://infinityglow.github.io/study/algorithm/advanced-algorithm/p-np/)\n"},{"title":"手把手教你用VPS搭建SS+bbr实现科学上网","url":"/others/ss_v2ray/ss/","content":"\n## 写在前面\n\n  首先先声明一下，本文不带有任何商业性质，单纯地是想方便海内外学生党使用Google、YouTube、Wikipedia等工具来查阅资料，作为一个Google和Wikipedia的重度使用者，有时候离开了这两样东西真的就没办法生活，所以做一个这方面的教程是非常有必要的。\n\n  如果你对访问外网的频率和带宽要求不高，用一般的免费vpn或者一些在线代理就足够了，市面上这些vpn哪个好用，哪个免费相信你们比我更清楚。如果要经常看YouTube高清视频或者连外服打游戏的小伙伴呢，这些免费但又不稳定的vpn自然就不能满足你们的需要了，所以得拥有一个自己专属的服务器来实现科学上网。\n\n## 基本原理\n\n![Shadowsocks基本原理](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/principle.png \"基本原理示意图\")\n\n  简单介绍一下ss的基本原理，其实ss就是隧道通信的一种，就是说从中国大陆直接访问Google、Facebook等黑名单网站是会被防火墙检测到并直接中断我们与这些服务器的连接的。这时候ss横空出世，作为一个中间者把我们将要发送给Google、Facebook服务器的请求经过本地(sslocal)加密，再将它们封装一下，与我们后面要部署的服务器达成通信协议。\n\n  当服务器(ssserver)端收到来自sslocal的数据之后，先解密，再将解密过后的数据发送给Google、Facebook服务器。当这些服务器把数据传回给ssserver过后，ssserver会将这些数据加密并打包发送给sslocal，sslocal拿到数据之后再进行解密，最后以网页的形式呈现出来。整个过程中，由于数据是进行加密的，所以防火墙是不知道我们在访问Google等外网的。\n\n  但据说最近ss已经能够被防火墙识别出来其特征，安全性存在一些漏洞，如果有空了可以再做一期v2ray的教程，其安全性和稳定性都要比ss要高。\n\n## 部署VPS\n\n  第一步需要部署我们的云服务器，这里先推荐一下[谷歌云](https://cloud.google.com)，可以免费试用一年的时间，并且还比较稳定，但有点麻烦的是需要你绑定信用卡，而且还必须是美国的。。。\n\n  这里我们演示的是一些主流服务商提供的VPS，话不多说，先推荐一波：\n\n  [搬瓦工](https://bandwagonhost.com)\n  [vultr](https://www.vultr.com)\n  [hostwind](https://www.hostwinds.com)\n  [time4vps](https://www.time4vps.com)\n\n  有的可能在国内被墙掉了，访问不了的只能自己想办法了。\n\n  这里以vultr为例，先进入官网。\n\n![vultr官网](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s1.png)\n  如果你是新用户，则需要先注册一下，这里点击“Sign up”。\n  点击之后，用你的邮箱作为用户名，然后自己创建一个密码。\n\n![vultr注册界面](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s2.png)\n  注册完以后登录即可。\n\n![vultr登录界面](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s3.png)\n  进入如下页面之后，选择“Product”，再点击右边的加号部署服务器。\n\n![部署服务器](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s4.png)\n![部署服务器](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s5.png)\n![部署服务器](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s6.png)\n\n  这里我们选择纽约的节点(因为最便宜)，然后系统选择Ubuntu 18.04，服务器配置根据自己的需求来选择。选完以后，点击下方的“Deploy Now”。付完款以后，将会出现如下的界面。\n![成功部署](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s7.png)\n\n## Shadowsocks服务器端配置\n\n  成功部署好VPS后就要开始服务器端的配置了。首先我们进入到服务器的信息页面(如下图所示)，我们需要记住这里的IP地址以及ssh远程登录时的密码。\n![服务器信息](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s10.png)\n\n  拿到IP地址以后可以先打开终端ping一下以确保服务器是否可用。我这里以Ubuntu系统作为演示，通信一切正常。\n![ping](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s9.png)\n\n  下一步就要用ssh命令远程登录我们的服务器了。Mac用户和Linux用户直接在终端使用ssh命令即可，Windows用户呢就要稍微麻烦一点，得先在网上下载PuTTY，然后再远程登录。\n\n``` bash\n$ ssh root@45.77.108.240\n```\n\n  按下回车后会叫你输入密码，也就是前面服务器信息里的密码。登录成功后就会出现下面的界面。\n\n![登录成功](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s12.png)\n\n  成功登录后，为了确保兼容性，需要更新一下软件包。\n\n``` bash\n$ sudo apt update\n$ sudo apt upgrade -y\n```\n\n  安装python和pip\n\n``` bash\n$ sudo apt install python\n$ sudo apt install python-pip\n```\n\n  安装shadowsocks\n\n``` bash\n$ pip install shadowsocks\n```\n  \n  在/etc/目录下创建shadowsocks.json配置文件\n\n``` bash\n$ vim /etc/shadowsocks.json\n```\n  \n  进入到vim界面之后，按i进入插入模式，然后按照下面的模板将服务器的配置信息写好(只需将端口号和密码改成自己想要的即可)，最后按”Esc“+“:wq”保存并退出\n\n`{\n    \"server\":\"0.0.0.0\",\n    \"server_port\": \"YOUR_PORT\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":\"1080\",\n    \"password\":\"YOUR_PASSWD\",\n    \"timeout\":\"500\",\n    \"method\":\"aes-256-cfb\"\n}`\n\n  配置文件写好以后就要启动我们的server了，在这里我们需要从配置文件中读取相应参数，因此ssserver命令需要加入-c参数。\n\n``` bash\n$ ssserver -c /etc/shadowsocks.json\n```\n\n  不出意外的话，第一次启动应该会报出“AttributeError: /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup”这样的错，这篇[博客](https://blog.csdn.net/St_Louis/article/details/103171781)给出了完美的解决方案，只需要修改一个文件中的两行数据就行，这里我就不一一演示了。\n\n  如果想要在后台运行，只需要在最后加入“-d start”即可。\n\n``` bash\n$ ssserver -c /etc/shadowsocks.json -d start\n```\n\n## Shadowsocks客户端配置\n\n  客户端比服务器端就要好配置多啦，三大主流操作系统都支持[图形化界面](https://github.com/shadowsocks/shadowsocks-gui)，Linux甚至支持还命令行的客户端。这里以Linux的GUI为例，只需要把服务器端的IP地址、端口号、密码、加密方式按照你服务器端配置的方式填写正确即可，剩下的本地地址、本地端口、协议类型就按照下面的方式填写就行了。\n\n![客户端配置](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s26.png)\n\n## 浏览器配置\n\n  虽然我们的服务器端和客户端都已经配置好了，但要在浏览器里实现外网的访问还需要几个简单的步骤。\n\n  首先需要在[chrome网上应用店](https://chrome.google.com/webstore/category/extensions?hl=zh-CN)下载一个叫做SwitchyOmega的插件。下载完成后在你的浏览器右上方会有一个小圆圈，点击后选择Option。\n![插件](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s15.png)\n\n  进入后选择左边的proxy，Protocol选择Socks5，Sever选择127.0.0.1，Port为1080。\n![Proxy](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s16.png)\n\n  保存退出后，就能访问Google啦～\n\n  但这样有一个问题，所有的流量都走了代理服务器，而平时我们访问一些国内的网站是不需要走代理的，并且用代理服务器来访问国内的网站会非常的慢。可不可以实现自动分流呢？哈哈，SwitchyOmega给我们了这样一个“贴心”的服务：auto switch\n\n  选择左边的auto switch，再选择“Add a rule list”\n\n![auto switch](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s17.png)\n\n  在\"Rule list rules\"选择\"proxy，Rule List Format\"选择\"AutoProxy\"\n\n![auto switch](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s21.png)\n\n  我们可以自定义规则，哪些网址走代理，哪些直接访问。但这样一个一个输入实在太麻烦，我们直接从GitHub上搜索gfwlist即可。\n\n  选择第一项\n![github gfwlist](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s18.png)\n\n  进入后点击gfwlist.txt，复制URL到SwitchyOmega中的Rule List URL，再点击Download Profile Now\n![auto switch](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s19.png)\n\n  更改应用后，你会发现下方的Rule List Text出现了各种网址，这说明已经添加成功了。\n![auto switch](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s23.png)\n\n  这样当我们把SwitchyOmega的模式选择成auto switch后就能实现智能分流啦。\n\n## bbr加速\n\n  最后，为了让我们的网速飞起来，看YouTube视频不会卡顿，需要借助一个叫做bbr加速的东西。操作非常简单，只需要几个步骤就好。这里需要再次登录我们的VPS，在VPS里进行操作。\n\n  修改系统变量并保存\n``` bash\n$ echo \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\n$ echo \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\n$ sysctl -p\n\n```\n\n  查看是否开启\n``` bash\n$ sysctl net.ipv4.tcp_available_congestion_control\n```\n\n  如果显示如下内容表示已经开启\n``` bash\n$ net.ipv4.tcp_available_congestion_control = reno cubic bbr\n```\n\n  查看BBR是否启动\n``` bash\n$ lsmod | grep bbr\n```\n\n  如果显示以下内容表示已经开启\n``` bash\n$ tcp_bbr                20480  25\n```\n\n  开启了bbr加速以后网速快的飞起，以我家的100M带宽为例，看YouTube 4k视频一点都不卡顿，网速也是相当给力的。\n![YouTube](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s25.png)\n\n"}]