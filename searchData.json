[{"title":"复杂度分析（递归）","url":"/study/algorithm/complexity-analysis/recursive/","content":"\n## 什么是递归\n\n前面我们对一些算法的复杂度进行了分析，但这些都是基于循环和迭代的，这一节我们会针对递归的算法进行复杂度分析。首先要需要知道什么是递归，**递归**（**recursion**）是函数调用自身的一个过程。举个例子，假设你是一个英语水平有限的人，你在读一段英文材料中遇到了某个生词，你需要查字典去了解这个单词的意思，但是字典只提供了英英字典，意味着你找到的单词下方的释义也有可能是你不认识的单词，于是你又继续查找那些单词的意思，而那些单词的释义有可能又出现你不认识的单词，你又继续查找直到你能够全部看懂为止。这样一个过程我们可以把它看做递归，因为查字典这个动作在不停地调用自身。\n\n![字典](https://infinityglow.github.io/study/algorithm/complexity-analysis/recursive/images/dictionary.jpg)\n\n试想如果你的英语水平很糟糕，你可能查了很久的字典还是没有弄明白这个生词是什么意思，甚至出现单词 A 用到了单词 B 做释义，单词 B 用到了单词 A 做释义这种情况，即无限循环。那么一次递归结束的条件是什么呢？显然，如果一个单词的释义你全都能看懂，当前递归就结束了，这种条件叫作**初始条件**（**initial condition**），也叫作递归的出口。\n\n## 阶乘的计算\n\n阶乘的计算大家应该都不陌生，一个数的阶乘 n ! = n × (n-1) × (n-2) × ... × 2 × 1，所以我们自然而然想到的计算方法是从 1 到 n 把它们乘起来，但只要我们稍微观察一下便可以得到 n ! = n × ( n - 1) ! 这样的关系式。这个关系式也不是一直递归下去的，同样需要一个出口，根据定义，0 的阶乘等于 1，所以当 n = 0 时递归停止。我们可以用几行代码轻松地实现它：\n\n```\ndef factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n-1)\n```\n\n如果用一个数学关系式是来表达是这样子的：\n\n![关系式](https://infinityglow.github.io/study/algorithm/complexity-analysis/recursive/images/relation0.png)\n\n我们观察可以得到这样的规律：问题的规模 n 在经过一次乘法运算 n × F(n - 1) 后变为了 n - 1，并且每经过一次乘法运算，问题的规模都减少了 1，所以要求这个算法的复杂度，我们可以推出如下的关系式：\n\n![关系式](https://infinityglow.github.io/study/algorithm/complexity-analysis/recursive/images/relation1.png)\n\n其中“+ 1”代表问题的规模每减少 1 就执行了一次乘法运算。这样的关系式叫作**递归关系式**（**recurrence relation**），要解出这个关系式，我们需要一步一步地推导，具体来讲就是先将 n - 1 代入式子中得到一个新的递归关系式，再将它代入到原式子中就可以得到 t(n) = t(n - 2) + 2，如此往复，直到出现递归出口。\n\n![推导](https://infinityglow.github.io/study/algorithm/complexity-analysis/recursive/images/derivation0.png)\n\n于是我们得出计算阶乘的时间复杂度为 O(n)。\n\n## 汉诺塔\n\n汉诺塔大家肯定都玩过，规则也很简单：有 A, B, C 三根柱子，上面穿有从大到小排列的圆盘，现在你需要借助 B 柱把 A 柱上的圆盘挪到 C 柱上，一次只能挪一个，但大的圆盘不能放在小的圆盘之上。\n\n ![演示](https://infinityglow.github.io/study/algorithm/complexity-analysis/recursive/images/demo.gif)\n\n那么它跟递归有什么关系呢？如果你是一个细心观察的人，你就会发现，要想把 n 个圆盘从 A 柱挪到 C 柱上，你首先要通过某种方法把 n - 1 个柱子从 A 挪到 B 柱上，给 A 柱上最大的圆盘“腾个位置”出来，然后把最大的圆盘移到 C 柱上，最后在通过某种方法把 B 柱上 n - 1 个圆盘挪到 C 柱上。至于怎么移动这 n - 1 个柱子，我们可以再用某种方法移动 n - 2 个柱子，给第二大的圆盘“腾位置”，再将 n - 2 个柱子移动到相应的柱子上。这样我们便可以一直递归下去，直到只有一个圆盘，也就是这里的递归出口了。\n\n我们用几张图来直观地理解一下，假设这里有 4 个圆盘，我们可以分为三个步骤：\n\n ![状态0](https://infinityglow.github.io/study/algorithm/complexity-analysis/recursive/images/state0.png)\n\n- 步骤一：将 3 个圆盘从 A 柱移动到 B 柱\n\n![状态1](https://infinityglow.github.io/study/algorithm/complexity-analysis/recursive/images/state1.png)\n\n- 步骤二：将 A 柱剩下的圆盘移动到 C 柱\n\n![状态2](https://infinityglow.github.io/study/algorithm/complexity-analysis/recursive/images/state2.png)\n\n- 步骤三：将 3 个圆盘从 B 柱移动到 C 柱\n\n![状态3](https://infinityglow.github.io/study/algorithm/complexity-analysis/recursive/images/state3.png)\n\n那么怎样来写递归关系式呢？我们看到，要解决 n 阶汉诺塔的问题，我们先要解决两个 n - 1 阶同样的问题，外加一个单次移动。所以我们的递归关系式应该这样写：\n\n![关系式](https://infinityglow.github.io/study/algorithm/complexity-analysis/recursive/images/relation2.png)\n\n我们还是采用回代的方式解出这个关系式：\n\n![推导](https://infinityglow.github.io/study/algorithm/complexity-analysis/recursive/images/derivation1.png)\n\n复杂度为 O(2<sup>n</sup>)，最后我们用代码来实现一下吧。\n\n```\ndef hanoi(a, b, c, n):\n    if n == 1:\n        print(\"{} -> {}\".format(a, c))\n        return\n    hanoi(a, c, b, n-1)  # c 柱为枢纽，将 a 柱中 n - 1 个圆盘移到 b 柱上\n    hanoi(a, b, c, 1)  # 将待移动的圆盘数设为 1\n    hanoi(b, a, c, n-1)  # a 柱为枢纽，将 b 柱中 n - 1 个圆盘移到 c 柱上\n```\n\n让我们试试 `n = 3` 时输出的结果：\n```\na -> c\na -> b\nc -> b\na -> c\nb -> a\nb -> c\na -> c\n```\n\n类似的例子还有很多，但它们的方法都是一样的。"},{"title":"复杂度分析（非递归）","url":"/study/algorithm/complexity-analysis/non-recursive/","content":"\n## 最好，最坏和平均情况\n\n一个算法的好坏并不是一成不变的，它会在不同的情况下有着不同的表现。先来看看一个生活中的场景，假设买彩票中奖的概率是1 / 10,000，那么在最好，最坏和平均的情况下需要买几注彩票才能够中奖呢？显然，如果你的运气够好，第一注你就直接中了，这是最好的情况；相反，如果你的手气够差，你买的彩票永远都中不了奖，这是最坏的情况；平均来讲，你需要买最少10,000注才能够中奖，其实就是这里的数学期望。\n\n![彩票](https://infinityglow.github.io/study/algorithm/complexity-analysis/non-recursive/images/lottery.jpg)\n\n这里的类比并不是想说明算法跟概率学有任何的关系，只是想告诉大家，算法的复杂度确实是有“运气”的成分，它取决于一个（类）问题的**实例**（**instance**）。这里的实例可以这样来理解：如果排序是我们要解决的问题，也就是对任意无序数组的有序化，那么一个实例就是一个具体的数组，比如 [3, 1, 2, 5, 4] 或 [1, 2, 3, 4, 5]。\n\n我们可以看到，后者的数组已经有序了，不需要再额外执行任何操作。对于有些排序算法来讲就可以利用这一点性质，减少执行的次数，让算法更有“远见”。像这样能使一个算法执行次数最少的情况我们把它称作**最好情况**（**best case**）。相反，使一个算法执行次数最多的情况叫做**最坏情况**（**worst case**）。最后剩下的**平均情况**（**average case**）指的是通常状态下算法的复杂度，它并不是等于（最好情况 + 最坏情况）/ 2 这么简单，而是要把所有的 instance 考虑在内，计算复杂度，然后再求一个平均值，后面的例子会详细讨论这个问题。\n\n## 顺序查找\n\n如果我们要查找数组里的某个元素，我们可以通过顺序查找的方式进行，也就是从左往右依次查找。代码如下：\n\n```\ndef find(array, element):\n    length = len(array)\n    for i in range(length):\n        if array[i] == element:\n            return i\n    return -1\n```\n\n我们用一个`for`循环遍历整个数组，如果找到了`element`就返回相应的索引值，否则返回 -1。判断这一条件是否成立的语句显然是 `if array[i] == element`，并且它是被执行的最多的语句，我们将这种执行次数最多，耗时最长的操作叫做**基本操作**（**basic operation**）。一般这种操作出现在最内层的循环，或者出现[递归](https://infinityglow/study/algorithm/complexity-analysis/recursive/)的地方。\n\n然后，我们来分析一下最好和最坏情况的时间复杂度。首先，最好的情况是循环的第一个元素就是我们要找的，比如我们要从数组 [3, 1, 2, 5, 4] 中找元素 3，那么时间复杂度显然就为 O(1)；最坏的情况是最后一个元素才是我们要找的或者查找失败，比如像这样的数组 [1, 2, 4, 5, 3] 需要执行 5 次基本操作。一般的情况，如果数组的长度为 n，则需要 n - 1 次，所以复杂度为 O(n)。\n\n最后我们来说一说平均复杂度，如果我们考虑了所有的情况，即查找的元素 `element` 在数组 `array` 的每一个位置都会出现，且出现的概率是相等的，那么我们可以通过这样一个式子来计算：\n\n![公式](https://infinityglow.github.io/study/algorithm/complexity-analysis/non-recursive/images/formula0.png)\n\n其中分子项为每一种情况需要查找的次数，最后得到的复杂度也为 O(n)，表明了在一般情况下该算法的时间复杂度也为线性复杂度。\n\n## 矩阵乘法\n\n让我们再来看一个例子，相信学过线性代数的小伙伴对矩阵的乘法应该不陌生，假设有两个矩阵 A (m × n) 和 B (n × p)，最后得到的矩阵 C (m × p) 中每一项都是 A 中每一行的 n 个元素和 B中每一列的 n 个元素乘积之和。下面是一个动图的演示（摘自[3Blue1Brown](https://www.youtube.com/watch?v=XkY2DOUCWMU)里的视频）：\n\n![矩阵乘法](https://infinityglow.github.io/study/algorithm/complexity-analysis/non-recursive/images/matmul.gif)\n\n如果写成 Python 的代码就是这样子的：\n\n```\ndef matmul(A, B):\n    n = len(A)\n    C = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                C[i][j] = C[i][j] + A[i][k] * B[k][j]\n    return C\n```\n\n这里为了计算方便，两个矩阵都采用了方阵的形式。很显然，这里的基本操作是 `C[i][j] + A[i][k] ∗ B[k][j]`。准确地来说，由于在计算机里做乘法比做加法所耗费的时间要大，所以 `A[i][k] ∗ B[k][j]` 才是我们的基本操作。\n\n分析完了基本操作，下面就来计算复杂度了。因为不管什么样的矩阵，它们执行的基本操作都是一样的，所以就不存在最好，最坏和平均情况的讨论了。于是根据循环我们可以得到：\n\n![公式](https://infinityglow.github.io/study/algorithm/complexity-analysis/non-recursive/images/formula1.png)\n\n其复杂度为 O(n<sup>3</sup>)。是不是很简单呢？类似的例子还有很多，但它们方法都是一样的。\n"},{"title":"三种表示方法：O, Ω, Θ","url":"/study/algorithm/complexity-analysis/three-notations/","content":"\n## 引入\n\n前面我们讲到了求最大公约数的算法：欧几里得算法。我们先举一个具体的实例：24 和 16 的公约数。根据其公式 `gcd(m, n) = gcd(n, m mod n)`，我们可以得到：`gcd(24, 16) = gcd(16, 8) = gcd(8, 0)`，所以最大公约数是 8。除了这种方法以外，我们还可以从 16 开始一个一个地递减，如果存在两数都能够被整除，那么这个数就是最大公约数。写成代码的形式就是：\n\n```\ndef gcd(m, n):\n    r = min(m, n)  # 选较小者\n    while r != 0:\n        if m % r == 0 and n % r == 0:\n            return r\n        r -= 1 \n``` \n\n我们可以计算得出，该算法的 if 语句被执行了 9 次，而前面的方法只执行了 3 次，我们看两者出现了差异，换句话说就是算法的效率出现了不同。下面就引出**时间复杂度**（**time complexity**）的概念：当一个问题的规模 n 趋向于无穷大的时候，算法所需要的时间 t(n) 。当然，如果一个算法需要很大的运行空间，那么**空间复杂度**（**space complexity**）就是当 n 趋向于无穷大的时候，算法所需要的空间 s(n) 。\n\n## 用于约束的 O, Ω, Θ\n\n那么问题来了，t(n) 的单位是什么呢？如果是秒的话，不同的计算机，不同的运行环境，计算出的结果肯定是不一样的，难以达到统一，这就需要我们定性的去描述这个问题，所以就有了用另一个函数来约束 t(n)。其中大 O 符号约束了 t(n) 的**上界**（**upper bound**）。换句话说，当 n 在趋近无穷大的时候，t(n) 的大小总是小于等于某个函数。举个例子，前面用迭代法求最大公约数所耗费的时间跟问题的规模明显呈现的是一个线性关系，那么我们可以这样表示：t(n) ∈ O(g(n))，其中 g(n) = n。当然，t(n) 也满足 t(n) ∈ O(n<sup>2</sup>)。这里为了更好的理解，没有采用严格的数学定义，感兴趣的同学可以去[维基百科](https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7)一探究竟，这里我们就不细讲了。\n\n同样，大 Ω 符号约束了 t(n) 的**下界**（**lower bound**），即 n 在趋近无穷大的时候，t(n) 总是大于等于某个函数。还是拿刚才的例子，t(n) 我们可以表示为 t(n) ∈ Ω(n)，代表其时间复杂度不会低于线性的复杂度，当然也不会低于常数的复杂度（不随 n 的变化而变化），所以也有：t(n) ∈ Ω(1)。\n\n剩下的 Θ 符号就代表的是 t(n) 的**确界**（**tight**）了，就是说 n 在趋近无穷大的时候跟它时间复杂度一样的一个函数。所以前面的例子就有：t(n) ∈ Θ(n)。最后用三张图来直观地感受一下吧！\n\n![illustration](https://infinityglow.github.io/study/algorithm/complexity-analysis/three-notations/images/illustration.png)\n\n## 复杂度的比较\n\n如果给定两个时间复杂度 O(f(n)) 和 O(g(n))，怎样来判断哪个时间复杂度比较大呢？根据复杂度的定义我们知道，一个函数在趋向于无穷大时的变化情况决定了复杂度的大小，而要比较两者的大小，我们可以通过做商的方式，像这样：![limit0](https://infinityglow.github.io/study/algorithm/complexity-analysis/three-notations/images/limit0.png) 这个极限可能会出现好几种情况，让我们分别来看看吧。\n\n- 情况1 极限为 0\n\n   假设 f(n) = n，g(n) = n<sup>2</sup>。那么我们就可以得出极限为 0 ![limit1](https://infinityglow.github.io/study/algorithm/complexity-analysis/three-notations/images/limit1.png) 这样我们可以认为 f(n) 的增长慢于 g(n) 的增长，即 f(n) 的复杂度低于 g(n) 的复杂度。\n\n- 情况2 极限为 ∞\n   \n     假设 f(n) = n，g(n) = log n。由于极限是无穷比无穷的未定式，所以我们可以借助洛必达法则，最后得出极限为 ∞ ![limit2](https://infinityglow.github.io/study/algorithm/complexity-analysis/three-notations/images/limit2.png) 这样我们可以认为 f(n) 的增长快于 g(n) 的增长，即 f(n) 的复杂度高于 g(n) 的复杂度。\n     \n- 情况3 极限为 c\n   \n     假设 f(n) = 3n<sup>2</sup> + 5，g(n) = 7n<sup>2</sup> + log n。同样借助洛必达法则，最后得出极限为一常数 c ![limit3](https://infinityglow.github.io/study/algorithm/complexity-analysis/three-notations/images/limit3.png) 这样我们可以认为 f(n) 的增长快慢和 g(n) 相同，即 f(n) 的复杂度和 g(n) 的复杂度相同。\n    \n从情况 3 我们可以观察出，两个函数的复杂度都由前面的部分决定（3n 和 7n），这间接地说明了前面的部分占据了主要的地位，于是我们可以把一些常见的复杂度排个序，并用一张图展示出来。\n\n![comparison](https://infinityglow.github.io/study/algorithm/complexity-analysis/three-notations/images/comparison.png)\n\n从左上到右下，其大小排列依次是：O(2<sup>n</sup>) > O(n<sup>3</sup>) > O(n<sup>2</sup>) > O(nlog n) > O(n) > O(log n) > O(1)\n\n\n"},{"title":"算法的问题类型","url":"/study/algorithm/basic-knowledge/problem-types/","content":"\n## 概述\n\n前面讲到了很多关于数据结构的概念，后面的内容就要用这些数据结构和算法来解决具体的问题了。那么首先我们是不是要对这些问题归一个类呢？废话不多说，直接先列举出来，主要分为五大类：\n\n- 排序问题\n- 搜索问题\n-  图的问题\n-  几何问题\n- 组合问题\n\n## 排序问题\n\n排序问题是计算机科学里最基础，也是最重要的问题，很多情况下直接决定了你设计的程序的效率，因为大部分的程序都会用到排序。在实际生活中排序也是用处多多。一个最简单的例子就是国外大学的招生办将申请者的 GPA 全部导入到 Excel 中，然后将它们从高到低依次排序来筛选他们想要的学生。\n\n排序所要实现的功能也很简单，我们的输入可以是一串无序的数字或者字母，输出就是从大到小或从小到大排列的有序数组，像这样：\n\n![排序](https://infinityglow.github.io/study/algorithm/basic-knowledge/problem-types/images/sorting.png)\n\n## 搜索问题\n\n搜索也是我们无时不刻都会用到的一个功能。Google 和百度的服务器每天都要从互联网上爬取海量的数据，然后将它们放在搜索树中以便于用户的查找。试想，如果这个搜索的效率很低很低，要几十秒甚至是几分钟才搜索出结果，那这两家公司可能也不会有今天的成就了吧。\n\n所以这就是我们要讨论的第二个问题：搜索问题。它可以再分为两个类，一个是用于单一键的搜索，例如下面这颗二叉树，我们要搜索 `Key = 35` 的节点是否存在：\n\n![搜索](https://infinityglow.github.io/study/algorithm/basic-knowledge/problem-types/images/search.png)\n\n第二个问题是关于**字符串匹配**（**string matching**）的。假设我们有一段英文：“A fall into a pit, a gain in your wit.”，现在要从里面查找“pit”这个单词以及它所处的位置。跟第一种不同的是，我们要查找的不再是一个单一的键而是一个字符串。这样就和我们从网页或电子书里搜索一段话没什么区别了。\n\n## 图的问题\n\n图的问题可谓是应用面最广的问题类型之一了。当我们开车迷路时，我们的手机里的高德地图总是给我们规划好距离最短的路线，或是耗时最短的路线，引领着我们到家。再就是小的时候玩过的“一笔画”游戏，其抽象成图的问题就为：给定一些图的节点和边 `<V, E>` ，总是存在一条路径包含了所有的边，且每条边只能被访问一次。下图就分别列举出了存在和不存在的情况。这些通通都要用到图的算法来解决。\n\n![一笔画](https://infinityglow.github.io/study/algorithm/basic-knowledge/problem-types/images/E-path.png)\n\n## 几何问题\n\n几何问题当然就是讨论关于点、线、面的问题啦。这里有一个最经典的问题：邮局选址问题。问题的描述是一条笔直的马路两侧分布着一些村庄，现在要在这些村庄之间修建一个邮局，使得所有村庄离这个邮局的距离之和最短。后面我们还会讨论**最短点对问题**（**closest-pair problem**）和**凸包问题**（**convex-hull problem**）。\n\n![邮局](https://infinityglow.github.io/study/algorithm/basic-knowledge/problem-types/images/post-office.jpg)\n\n## 组合问题\n\n前面提到的“一笔画”问题不仅是关于图的问题，同样它也是一个组合问题，这样的问题试图从排列组合中找到答案。我们知道，排列组合问题的规模一般都非常大，所以组合问题也是算法里面最耗时，最难解决的一类问题。后面我们还会讨论[背包问题](https://infinityglow.github.io/study/algorithm/dynamic-programming/knapsack-problem/)等一系列组合问题。\n\n![背包问题](https://infinityglow.github.io/study/algorithm/basic-knowledge/problem-types/images/knapsack.png)\n\n"},{"title":"基本数据结构","url":"/study/algorithm/basic-knowledge/data-structure/","content":"\n## 概念\n\n如果说程序员是用代码编织这个世界的一群人，那么**数据结构**（**data structure**）就是编织所用到的各种工具了，它将计算机中各种各样的数据组织在一起。而我们的算法就是利用这些现有的工具将它们拼接成风格、功能各不相同的程序了。简单来说：算法 + 数据结构 = 程序。这一节就让我们来了解一些基本的数据结构吧。\n\n## 数组与链表\n\n我们从最简单的一维数据结构开始。数组大家应该都不陌生，它是将一组相同数据类型的数据存储在一起的数据结构。\n\n![数组](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/array0.png)\n\n这里我们分析一下最基本的三大操作：查找、插入和删除。\n\n拿上面的图为例，因为数组中每一个**元素**（**element**）都有自己的一个下标，称为**索引**（**index**），它们被存储在计算机的RAM中，所以查找的速度非常快。一般查找的时间不随数组长度而增加。\n\n插入和删除就要稍微麻烦一些。因为数组占用的是计算机内存的连续地址空间，所以在插入一个新元素时，所有在它后面的元素都要向后移动一个单位，为新元素“腾出”位置。同理，为了保持数组的完整性，删除一个元素后，所有在它后面的元素也要向前移动一个单位，以此来“填充”空位。\n\n以这里的数组为例，如果我们要删除 `index = 5` 的元素，那么在它后面的 `15`，`34` 和 `80` 都要向前移动一个单位，如下图中所示。\n\n![数组](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/array1.png)\n\n让我们用Python代码来实现一下。\n\n```\n# 查找\ndef search(array, element):\n    length = len(array)\n    for i in range(length):\n        if array[i] == element:\n            return i\n    return -1\n\n# 插入\ndef insert(array, idx, element):\n    new_array = array.copy() + [None]  # 复制原数组到一个新数组\n    length = len(new_array); i = length - 1\n    # 所有idx之后的元素向右移动一个单位\n    while i > idx:\n        new_array[i] = new_array[i-1]\n        i -= 1\n    new_array[idx] = element\n    return new_array\n\n# 删除\ndef remove(array, element):\n    length = len(array)\n    idx = search(array, element)  # 找到对应索引\n    if idx != -1:\n        # 如果查找成功，所有在idx之前的元素向左移动一个单位\n        while idx < length - 1:\n            array[idx] = array[idx+1]\n            idx += 1\n        array = array[: -1]\n    return array\n```\n\n再来说一说链表。与数组采取的顺序存储方式不同，链表中所有的元素的存储地址都是分散的，也就是说，它是靠一条链条（指针）把这些元素联系在一起的。所以我们把链表中每一个存储单元称为一个**节点**（**node**），在每个节点里有两个域：一个用来存储数据，一个是指针指向下一个节点，像这样：\n\n![链表](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/linked-list0.png)\n\n在Python中我们用一个类来表示：\n\n```\nclass Node(object):\n    def __init__ (self, value, next):\n        self.value = value\n        self.next = None\n```\n\n如果将它们串联在一起，将会是这样：\n\n![链表](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/linked-list1.png)\n\n其中的`header`指的是头结点，它一般记录第一个节点的地址和链表的长度，我们在查找的时候就是从头结点开始的，代码如下：\n\n```\nclass Linked_List(object):\n    def __init__ (self):\n        self.length = 0\n        self.header = None\n    def search(self, value):\n        p = self.header  # 获取第一个节点\n        while p != None:\n            if p.value == value:\n                return p\n            p = p.next\n        return None\n```\n\n和数组相比，链表的插入和删除就非常的简单，只需要改变一下指针即可。下面还是以插入元素`61`为例：\n\n首先需要新建一个节点p\n\n![链表](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/linked-list2.png)\n\n然后，p的指针指向头结点所指的节点\n\n![链表](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/linked-list3.png)\n \n最后，改变头结点的指针，使其指向p，同时更新链表的长度length。\n\n![链表](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/linked-list4.png)\n\n插入和删除的Python实现：\n\n```\nclass Linked_List(object):\n    def __init__ (self):\n        self.length = 0\n        self.header = None\n    def insert(self, value):\n        # 新建一个节点\n        p = Node(value)\n        p.next = self.header\n        self.header = p\n        self.length += 1\n    def remove(self):\n        p = self.header  # 获取第一个节点\n        if p is not None:\n            self.header = p.next\n            self.length -= 1\n            del p  # 删除节点 p\n```\n\n## ADT\n\n**抽象数据类型**（**Abstract Data Type**, 简称**ADT**）是数据结构中非常重要的一个部分。用最简单的理解方式就是：不仅限于编程语言中已经实现的一些数据类型，例如 Python 中 list，set，tuple，dictionary 等等。我们可以进一步的定义出属于我们自己数据结构，比如说增删只能在一侧进行，具有层状、环状的结构等等。那就让我们来看看几个最为常见的例子吧～\n\n### 栈\n\n**栈**（**stack**）就是前面提到的只能在一侧进行元素的增加和删除的数据结构，这种过程分别称为**入栈**(**push**)和**出栈**(**pop**)。生活中最简单的类比就是叠盘子，新洗好的盘子总是放在最上面，而拿走的时候总是从最上面一个拿走。这种后进先出（**last in, first out**）的方式就体现了这种思想。\n\n![栈](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/stack.jpeg)\n\n### 队列\n\n和栈相反，**队列**（**queue**）是遵循**先进先出**（**first in, first out**）的方式实现元素的增减，其过程分别叫做**入队**（**enqueue**）和**出队**（**dequeue**）。生活中的例子就是去超市收银台排队的时候，排到队伍后面的人要先等前面的人都结完账了自己才能结账，所以这就是先进先出啦。\n\n![队列](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/queue.png)\n\n因为和前面的数组和链表有相似性，所以这里就不再用Python代码做演示了，你可以去我的[GitHub](https://github.com/infinityglow/Algorithm-and-Complexity/tree/master/Basic%20Knowledge/Data%20Structure)主页查看本节的完整代码。\n\n### 树\n\n与前面的数据结构不同，**树**（**tree**）是典型的层状数据结构。直观上来看，它就像倒挂着的一颗树，每一个节点连接着多个子节点。这里为了方便，我们只讨论**二叉树**（**binary tree**），也就是每一个节点最多只有两个子节点的情况。\n\n![树](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/tree0.png)\n\n下面来简单介绍一下二叉树的性质。和所有树状结构一样，二叉树在非空的情况下一定有一个**根节点**（**root node**），如图中的节点26。它的两个子节点我们分别把它们叫做该节点的**左孩子**（**left child**）和**右孩子**（**right child**），而对于那些没有孩子的节点，我们把它称做**叶子节点**（**leaf node**）。前面只是针对节点的讨论，而对于树本身，我们要了解的是满二叉树和完全二叉树。\n\n满二叉树是指每一个节点孩子的个数只能为0或2，如下图所示，左边是一颗满二叉树，但右边由于节点48只有一个孩子，所以就不是满二叉树。\n\n![树](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/tree1.png)\n\n再来看完全二叉树，它的性质是除了最后一层的节点没有排满以外，其他层的节点均已排满，并且最后一层节点都是从左往右依次排列。下图的两个例子分别代表了完全二叉树和非完全二叉树。后面的[堆](https://infinityglow.github.io/study/algorithm/transform-and-conquer/heap/)也会用到这种性质。\n\n![树](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/tree2.png)\n\n在Python中我们可以用一个类来表示树的节点：\n\n```\nclass Node(object):\n    def __init__ (self, value):\n        self.value = value\n        self.left = None  # 左孩子\n        self.right = None  # 右孩子\n```\n\n### 图\n\n**图**（**graph**）是 ADT 中用到的最多的结构，生活中的方方面面都会用到图。例如，高德地图就是把所有城市，所有道路通通抽象成了图这种数据结构来帮助我们导航的。哈哈，厉害吧！那我们就首先来了解一下图的基本结构。\n\n图也是由一个一个的**节点**（**vertex**）组成的。但与树不同的是，图的节点之间相连的叫做**边**（**edge**），所以我们用 G = <V, E> 来表示一张图，其中的 V 表示由 vertex 构成的集合，而 E 则表示由 edge 构成的集合。\n\n图的分类一般有好几种，如果一个节点到另一个节点是双向的我们把它叫做**无向图**（**undirected graph**），如果是单向的就叫**有向图**（**undirected graph**），下图中就分别代表了无向图和有向图。\n\n![图](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/graph0.png)\n\n假如从一个节点到另一个节点是要付出“代价”的，那么我们就可以在每一条边上把这种“代价”体现出来，称之为**权重**（**weight**），而构成这样的图当然就叫做**有权图**（**weighted graph**）了。\n\n![图](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/graph1.png)\n\n我们可以用两种方式来表示一张图，一种叫做**邻接矩阵**（**adjacency matrix**）和**邻接表**（**adjacency list**），后面的内容会详细讨论，先上图。\n\n![图](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/images/graph2.png)\n\n这样我们就完成所有基本数据结构的学习了，是不是对它们有了清晰的认识呢？\n\n[本节全部代码](https://github.com/infinityglow/Algorithm-and-Complexity/tree/master/Basic%20Knowledge/Data%20Structure)\n"},{"title":"算法与复杂度","url":"/study/algorithm/overview/","content":"\n## 前言\n\n这个系列的博文会逐个介绍计算机科学里面最基础、也是最重要的一部分内容：**算法**(**algorithm**)。提到它，这可能是你最擅长的部分，亦或是你学生生涯的噩梦。不管怎么样，对于学计算机的小伙伴来讲，它始终是不可回避的一个话题。不论是学生时代的你还是已经踏上了工作的岗位，算法都会一直陪伴着你。\n\n为什么要做这个系列呢？因为网上对于这一块的内容实在是太多，甚至是太杂，而很少有把算法的知识体系整合起来形成一个系列的教学博客。于是乎想尽自己的微薄之力，让更多的人能够更好地理解算法，在未来求职的面试中不再因为它而与自己理想的公司失之交臂。\n\n我将与国内的教学方式和教学内容有所差别。形式上不再是只针对如何解决这个问题，因为只会解决问题并不代表真正理解这个问题。我会花一些篇幅着重介绍一些概念性的内容，这也是国内的教学最欠缺的部分。国内的课堂不会告诉你自然对数e与自然界生长的规律有关；学完了线性代数，你可能光学会了如何解行列式，却忽视了行列式也是有几何意义的。内容上不再按照“排序算法”、“搜索算法”等方式分类，而采用了问题解决的不同方式来划分，比如“暴力求解”、“分治法”、“动态规划”等等。当然，我也是参考了Levitin编写的教材[Introduction to The Design and Analysis of Algorithms, 3rd Edition](https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/Introduction%20to%20the%20Design%20and%20Analysis%20of%20Algorithms%20%283rd%20ed.%29%20%5BLevitin%202011-10-09%5D.pdf)。要是你觉得这本书讲得太基础，你也可以参考MIT的[《算法导论》](http://kddlab.zjgsu.edu.cn:7200/students/lipengcheng/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%88%E8%8B%B1%E6%96%87%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89.pdf)。\n\n编程语言我会采用Python，因为Python是最接近这些英文书里用于讲解的伪代码，理解起来会更加方便。对于刚入门的小白来讲，Python的简洁不会让你因为不能理解编程语言本身而最终放弃了这门课程的学习。我会把每一节的内容的完整代码都放在我的[GitHub](https://github.com/infinityglow/Algorithm-and-Complexity)的 Algorithm 仓库里，方便学习后用代码真正实现它们。\n\n最后，要是讲解有任何疑问，欢迎在评论区留言。如果发现了有任何错误和表述不规范的地方，希望各位大佬轻喷，毕竟我也是第一次写博客，有错误也是在所难免的。\n\n## 总览\n\n### 介绍 (Introduction)\n\n&emsp;[1.1 什么是算法](https://infinityglow.github.io/study/algorithm/introduction/)\n\n### 基本知识 (Basic Knowledge)\n\n&emsp;[2.1 基本数据结构](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/)\n&emsp;[2.2 算法的问题类型](https://infinityglow.github.io/study/algorithm/basic-knowledge/problem-types/)\n\n### 复杂度分析 (Complexity Analysis)\n\n&emsp;[3.1 三种表示方法：O, Ω, Θ](https://infinityglow.github.io/study/algorithm/complexity-analysis/three-notations/)\n&emsp;[3.2 复杂度分析（非递归）](https://infinityglow.github.io/study/algorithm/complexity-analysis/non-recursive/)\n&emsp;[3.3 复杂度分析（递归）](https://infinityglow.github.io/study/algorithm/complexity-analysis/recursive/)\n\n### 暴力求解 (Brute Force)\n\n&emsp;[4.1 冒泡排序与选择排序](https://infinityglow.github.io/study/algorithm/brute-force/bubble-selection-sort/)\n&emsp;[4.2 顺序查找与字符串匹配（BF）](https://infinityglow.github.io/study/algorithm/brute-force/string-matching/)\n&emsp;[4.3 图的两种遍历](https://infinityglow.github.io/study/algorithm/brute-force/graph-traversal/)\n&emsp;[4.4 最近点对与凸包问题（BF）](https://infinityglow.github.io/study/algorithm/brute-force/clo-pair-con-hull/)\n&emsp;[4.5 暴力搜索](https://infinityglow.github.io/study/algorithm/brute-force/exhaustive-search/)\n\n### 减治法（Decrease and Conquer）\n\n&emsp;[5.1 插入排序](https://infinityglow.github.io/study/algorithm/decrease-and-conquer/insertion-sort/)\n&emsp;[5.2 拓扑排序](https://infinityglow.github.io/study/algorithm/decrease-and-conquer/topo-sorting/)\n&emsp;[5.3 二分查找与二叉树](https://infinityglow.github.io/study/algorithm/decrease-and-conquer/binary-search-tree/)\n&emsp;[5.4 插值查找](https://infinityglow.github.io/study/algorithm/decrease-and-conquer/interpolation-search/)\n\n### 分治法（Divide and Conquer）\n\n&emsp;[6.1 归并排序](https://infinityglow.github.io/study/algorithm/divide-and-conquer/merge-sort/)\n&emsp;[6.2 快速排序](https://infinityglow.github.io/study/algorithm/divide-and-conquer/quick-sort/)\n&emsp;[6.3 二叉树的遍历](https://infinityglow.github.io/study/algorithm/divide-and-conquer/bt-traversal/)\n&emsp;[6.4 最近点对与凸包问题（DC）](https://infinityglow.github.io/study/algorithm/divide-and-conquer/clo-pair-con-hull/)\n\n### 变治法（Transform and Conquer）\n\n&emsp;[7.1 预排序](https://infinityglow.github.io/study/algorithm/transform-and-conquer/presorting/)\n&emsp;[7.2 霍纳法则](https://infinityglow.github.io/study/algorithm/transform-and-conquer/horners-rule/)\n&emsp;[7.3 堆与堆排序](https://infinityglow.github.io/study/algorithm/transform-and-conquer/heap/)\n&emsp;[7.4 AVL树](https://infinityglow.github.io/study/algorithm/transform-and-conquer/AVL-tree/)\n&emsp;[7.5 红黑树](https://infinityglow.github.io/study/algorithm/transform-and-conquer/R&B-tree/)\n&emsp;[7.6 2-3树](https://infinityglow.github.io/study/algorithm/transform-and-conquer/two-three-tree/)\n\n### 时空权衡（Time Space Tradeoff）\n\n&emsp;[8.1 计数排序](https://infinityglow.github.io/study/algorithm/time-space-tradeoff/counting-sort/)\n&emsp;[8.2 字符串匹配（TST）](https://infinityglow.github.io/study/algorithm/time-space-tradeoff/string-matching/)\n&emsp;[8.3 哈希](https://infinityglow.github.io/study/algorithm/time-space-tradeoff/hashing/)\n\n### 动态规划（Dynamic Programming）\n\n&emsp;[9.1 关于钱的两个经典问题](https://infinityglow.github.io/study/algorithm/dynamic-programming/classic-problems/)\n&emsp;[9.2 背包问题（DP）](https://infinityglow.github.io/study/algorithm/dynamic-programming/knapsack-problem/)\n&emsp;[9.3 弗洛伊德算法](https://infinityglow.github.io/study/algorithm/dynamic-programming/Floyd-Warshall/)\n  \n### 贪心算法（Greedy Algorithm）\n\n&emsp;[10.1 普林姆算法](https://infinityglow.github.io/study/algorithm/greedy-algorithm/Prim/)\n&emsp;[10.2 克鲁斯卡尔算法](https://infinityglow.github.io/study/algorithm/greedy-algorithm/Kruskal/)\n&emsp;[10.3 迪克斯特拉算法](https://infinityglow.github.io/study/algorithm/greedy-algorithm/Dijkstra/)\n&emsp;[10.4 哈弗曼树](https://infinityglow.github.io/study/algorithm/greedy-algorithm/Huffman-tree/)\n\n### *高阶算法（Advanced Algorithm）\n\n&emsp;[*回溯](https://infinityglow.github.io/study/algorithm/advanced-algorithm/backtracking/)\n&emsp;[*分支限界](https://infinityglow.github.io/study/algorithm/advanced-algorithm/branch-and-bound/)\n&emsp;[*线性规划（单纯形法）](https://infinityglow.github.io/study/algorithm/advanced-algorithm/linear-programming/)\n&emsp;[*最大流问题](https://infinityglow.github.io/study/algorithm/advanced-algorithm/maximum-flow/)\n&emsp;[*匈牙利算法](https://infinityglow.github.io/study/algorithm/advanced-algorithm/hungarian-algorithm/)\n&emsp;[*千禧问题：P = NP ?](https://infinityglow.github.io/study/algorithm/advanced-algorithm/p-np/)\n\n"},{"title":"手把手教你用VPS搭建SS+bbr实现科学上网","url":"/others/ss_v2ray/ss/","content":"\n## 写在前面\n\n  首先先声明一下，本文不带有任何商业性质，单纯地是想方便海内外学生党使用Google、YouTube、Wikipedia等工具来查阅资料，作为一个Google和Wikipedia的重度使用者，有时候离开了这两样东西真的就没办法生活，所以做一个这方面的教程是非常有必要的。\n\n  如果你对访问外网的频率和带宽要求不高，用一般的免费vpn或者一些在线代理就足够了，市面上这些vpn哪个好用，哪个免费相信你们比我更清楚。如果要经常看YouTube高清视频或者连外服打游戏的小伙伴呢，这些免费但又不稳定的vpn自然就不能满足你们的需要了，所以得拥有一个自己专属的服务器来实现科学上网。\n\n## 基本原理\n\n![Shadowsocks基本原理](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/principle.png \"基本原理示意图\")\n\n  简单介绍一下ss的基本原理，其实ss就是隧道通信的一种，就是说从中国大陆直接访问Google、Facebook等黑名单网站是会被防火墙检测到并直接中断我们与这些服务器的连接的。这时候ss横空出世，作为一个中间者把我们将要发送给Google、Facebook服务器的请求经过本地(sslocal)加密，再将它们封装一下，与我们后面要部署的服务器达成通信协议。\n\n  当服务器(ssserver)端收到来自sslocal的数据之后，先解密，再将解密过后的数据发送给Google、Facebook服务器。当这些服务器把数据传回给ssserver过后，ssserver会将这些数据加密并打包发送给sslocal，sslocal拿到数据之后再进行解密，最后以网页的形式呈现出来。整个过程中，由于数据是进行加密的，所以防火墙是不知道我们在访问Google等外网的。\n\n  但据说最近ss已经能够被防火墙识别出来其特征，安全性存在一些漏洞，如果有空了可以再做一期v2ray的教程，其安全性和稳定性都要比ss要高。\n\n## 部署VPS\n\n  第一步需要部署我们的云服务器，这里先推荐一下[谷歌云](https://cloud.google.com)，可以免费试用一年的时间，并且还比较稳定，但有点麻烦的是需要你绑定信用卡，而且还必须是美国的。。。\n\n  这里我们演示的是一些主流服务商提供的VPS，话不多说，先推荐一波：\n\n  [搬瓦工](https://bandwagonhost.com)\n  [vultr](https://www.vultr.com)\n  [hostwind](https://www.hostwinds.com)\n  [time4vps](https://www.time4vps.com)\n\n  有的可能在国内被墙掉了，访问不了的只能自己想办法了。\n\n  这里以vultr为例，先进入官网。\n\n![vultr官网](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s1.png)\n  如果你是新用户，则需要先注册一下，这里点击“Sign up”。\n  点击之后，用你的邮箱作为用户名，然后自己创建一个密码。\n\n![vultr注册界面](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s2.png)\n  注册完以后登录即可。\n\n![vultr登录界面](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s3.png)\n  进入如下页面之后，选择“Product”，再点击右边的加号部署服务器。\n\n![部署服务器](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s4.png)\n![部署服务器](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s5.png)\n![部署服务器](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s6.png)\n\n  这里我们选择纽约的节点(因为最便宜)，然后系统选择Ubuntu 18.04，服务器配置根据自己的需求来选择。选完以后，点击下方的“Deploy Now”。付完款以后，将会出现如下的界面。\n![成功部署](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s7.png)\n\n## Shadowsocks服务器端配置\n\n  成功部署好VPS后就要开始服务器端的配置了。首先我们进入到服务器的信息页面(如下图所示)，我们需要记住这里的IP地址以及ssh远程登录时的密码。\n![服务器信息](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s10.png)\n\n  拿到IP地址以后可以先打开终端ping一下以确保服务器是否可用。我这里以Ubuntu系统作为演示，通信一切正常。\n![ping](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s9.png)\n\n  下一步就要用ssh命令远程登录我们的服务器了。Mac用户和Linux用户直接在终端使用ssh命令即可，Windows用户呢就要稍微麻烦一点，得先在网上下载PuTTY，然后再远程登录。\n\n``` bash\n$ ssh root@45.77.108.240\n```\n\n  按下回车后会叫你输入密码，也就是前面服务器信息里的密码。登录成功后就会出现下面的界面。\n\n![登录成功](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s12.png)\n\n  成功登录后，为了确保兼容性，需要更新一下软件包。\n\n``` bash\n$ sudo apt update\n$ sudo apt upgrade -y\n```\n\n  安装python和pip\n\n``` bash\n$ sudo apt install python\n$ sudo apt install python-pip\n```\n\n  安装shadowsocks\n\n``` bash\n$ pip install shadowsocks\n```\n  \n  在/etc/目录下创建shadowsocks.json配置文件\n\n``` bash\n$ vim /etc/shadowsocks.json\n```\n  \n  进入到vim界面之后，按i进入插入模式，然后按照下面的模板将服务器的配置信息写好(只需将端口号和密码改成自己想要的即可)，最后按”Esc“+“:wq”保存并退出\n\n```{\n    \"server\":\"0.0.0.0\",\n    \"server_port\": \"YOUR_PORT\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":\"1080\",\n    \"password\":\"YOUR_PASSWD\",\n    \"timeout\":\"500\",\n    \"method\":\"aes-256-cfb\"\n}```\n\n  配置文件写好以后就要启动我们的server了，在这里我们需要从配置文件中读取相应参数，因此ssserver命令需要加入-c参数。\n\n``` bash\n$ ssserver -c /etc/shadowsocks.json\n```\n\n  不出意外的话，第一次启动应该会报出“AttributeError: /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup”这样的错，这篇[博客](https://blog.csdn.net/St_Louis/article/details/103171781)给出了完美的解决方案，只需要修改一个文件中的两行数据就行，这里我就不一一演示了。\n\n  如果想要在后台运行，只需要在最后加入“-d start”即可。\n\n``` bash\n$ ssserver -c /etc/shadowsocks.json -d start\n```\n\n## Shadowsocks客户端配置\n\n  客户端比服务器端就要好配置多啦，三大主流操作系统都支持[图形化界面](https://github.com/shadowsocks/shadowsocks-gui)，Linux甚至支持还命令行的客户端。这里以Linux的GUI为例，只需要把服务器端的IP地址、端口号、密码、加密方式按照你服务器端配置的方式填写正确即可，剩下的本地地址、本地端口、协议类型就按照下面的方式填写就行了。\n\n![客户端配置](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s26.png)\n\n## 浏览器配置\n\n  虽然我们的服务器端和客户端都已经配置好了，但要在浏览器里实现外网的访问还需要几个简单的步骤。\n\n  首先需要在[chrome网上应用店](https://chrome.google.com/webstore/category/extensions?hl=zh-CN)下载一个叫做SwitchyOmega的插件。下载完成后在你的浏览器右上方会有一个小圆圈，点击后选择Option。\n![插件](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s15.png)\n\n  进入后选择左边的proxy，Protocol选择Socks5，Sever选择127.0.0.1，Port为1080。\n![Proxy](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s16.png)\n\n  保存退出后，就能访问Google啦～\n\n  但这样有一个问题，所有的流量都走了代理服务器，而平时我们访问一些国内的网站是不需要走代理的，并且用代理服务器来访问国内的网站会非常的慢。可不可以实现自动分流呢？哈哈，SwitchyOmega给我们了这样一个“贴心”的服务：auto switch\n\n  选择左边的auto switch，再选择“Add a rule list”\n\n![auto switch](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s17.png)\n\n  在\"Rule list rules\"选择\"proxy，Rule List Format\"选择\"AutoProxy\"\n\n![auto switch](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s21.png)\n\n  我们可以自定义规则，哪些网址走代理，哪些直接访问。但这样一个一个输入实在太麻烦，我们直接从GitHub上搜索gfwlist即可。\n\n  选择第一项\n![github gfwlist](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s18.png)\n\n  进入后点击gfwlist.txt，复制URL到SwitchyOmega中的Rule List URL，再点击Download Profile Now\n![auto switch](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s19.png)\n\n  更改应用后，你会发现下方的Rule List Text出现了各种网址，这说明已经添加成功了。\n![auto switch](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s23.png)\n\n  这样当我们把SwitchyOmega的模式选择成auto switch后就能实现智能分流啦。\n\n## bbr加速\n\n  最后，为了让我们的网速飞起来，看YouTube视频不会卡顿，需要借助一个叫做bbr加速的东西。操作非常简单，只需要几个步骤就好。这里需要再次登录我们的VPS，在VPS里进行操作。\n\n  修改系统变量并保存\n``` bash\n$ echo \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\n$ echo \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\n$ sysctl -p\n\n```\n\n  查看是否开启\n``` bash\n$ sysctl net.ipv4.tcp_available_congestion_control\n```\n\n  如果显示如下内容表示已经开启\n``` bash\n$ net.ipv4.tcp_available_congestion_control = reno cubic bbr\n```\n\n  查看BBR是否启动\n``` bash\n$ lsmod | grep bbr\n```\n\n  如果显示以下内容表示已经开启\n``` bash\n$ tcp_bbr                20480  25\n```\n\n  开启了bbr加速以后网速快的飞起，以我家的100M带宽为例，看YouTube 4k视频一点都不卡顿，网速也是相当给力的。\n![YouTube](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s25.png)\n\n"},{"title":"什么是算法","url":"/study/algorithm/introduction/","content":"\n## 概念\n\n什么是算法？英文维基百科给出了这样的定义：“An algorithm is a finite sequence of well-defined, computer-implementable instructions, typically to solve a class of problems or to perform a computation.”翻译过来的意思就是一系列有限的、清晰定义的、可实现的计算机指令，并用以解决一类问题或进行计算。\n\n是不是被这么官方的定义搞懵了？在生活中一个最简单的类比就是烹饪。如果把要烧一道菜比作这里要解决的问题，那么菜谱中每一道工序，每一个步骤就是这道菜的“算法”了。但这样的类比也存在一些问题：我们的算法要求每一步都是要明确定义，也就是说不能有任何歧义的。还是拿做菜来讲，如果菜谱上是这样定义的：\n\n- 将油倒入锅中加热至七成热\n- 把鸡腿放入油锅中炸至金黄\n- 放入少许盐\n\n![炸鸡腿](https://infinityglow.github.io/study/algorithm/introduction/images/chicken-leg.jpg)\n\n以上的步骤虽然前后有逻辑性，最终能够做出炸鸡腿，但是这样的定义是不符合算法的规范的，因为这样的定义只具备了**经验性**（**empirical**），不具备**系统性**（**systematical**），计算机是读不懂人类的这些经验的。所以，正确的姿势应该是这样的：\n\n- 将200ml的色拉油放入铁锅中，打开电炉，调至第9档，当油温达到200°C后停止加热\n- 把碗里的鸡腿依次放入油锅中煎炸，直至鸡腿表面呈现出 #FF9900 (金黄色RGB的十六进制表示法)\n- 根据鸡腿的重量（g）和一个映射函数 f(x) 计算出需要放置的盐的重量（g），将其放入锅中\n\n这样我们的计算机就好理解多啦～\n\n![happy](https://infinityglow.github.io/study/algorithm/introduction/images/happy.jpg)\n\n## 解决的问题\n\n了解完了算法的概念，那么算法是要用来干什么的呢？前面提到了是用来解决一类问题，这样的问题可以是[排序](https://infinityglow.github.io/tags/sorting/), [查找](https://infinityglow.github.io/tags/search/)，最优化问题等等。总之，这些问题大部分都是有确定解的，我们只需要用其中的一种算法找到它们即可。\n\n但是，仅仅找到了算法来解决这些问题是远远不够的。我们还需要考虑这个算法的效率如何，也就是对其进行[复杂度](https://infinityglow.github.io/study/algorithm/complexity-analysis/three-notations)分析。这里暂时不做讨论，先举一个经典的算法问题：扔鸡蛋问题。假设楼高为100层，给你2个鸡蛋，你需要试出来从第几层往下扔鸡蛋刚好会碎。你可能首先想到的是从第一层开始一层一层地扔直到鸡蛋摔碎，但是这样你可能最多扔99次（假设从100层往下扔鸡蛋才碎），而且你没有利用上第二个鸡蛋。一些聪明的同学可能又想到了用一个鸡蛋十层十层地往上扔，如果碎了就在两个十层之间一层一层地往上扔。这样最多只要扔19次，已经比之前的方法有了明显的进步，这就是算法要考虑的效率问题。事实上，这个问题的最优解是最多扔14次，需要后面要讲到的[动态规划](https://infinityglow.github.io/tag/dp/)。\n\n![扔鸡蛋](https://infinityglow.github.io/study/algorithm/introduction/images/egg.png)\n\n## 例子\n\n让我们看一道完整的例子，求两个数的最大公约数。相信在中学阶段老师就告诉过你们把两个数的因子提取出来，然后把所有共同的因子相乘得到结果。这里我们对这种方法不做讨论，让我们先看看一种高效的解法：**欧几里得算法**（**Euclid's algorithm**）。\n\n欧几里得算法又叫辗转取余法，其原理是两个数的最大公约数等于较小数与两数取余的最大公约数，用数学语言来描述的话就是 `gcd(m, n) = gcd(n, m mod n)`。但这只是其中的一步，什么时候才返回我们想要的结果呢？这就需要用算法语言来描述这个过程，这种语言可以是自然语言，也可以是数学语言（伪代码）。让我们先以自然语言为例吧。\n\n- 第一步：如果 n = 0，返回m；否则执行第二步。\n- 第二步：m 除以 n，将余数赋给变量r。\n- 第三步：把 n 赋给 m，r 赋给 n。执行第一步。\n\n如果用伪代码来表示的话就是这样的：\n\n![伪代码](https://infinityglow.github.io/study/algorithm/introduction/images/Euclid.png)\n\n最后，让我们用Python来实现这个函数吧。\n\n```\ndef gcd(m, n):\n    while n != 0:\n        r = m\n        m = n\n        n = r % n\n        gcd(m, n)\n    return m\n```\n\n[本节全部代码](https://github.com/infinityglow/Algorithm-and-Complexity/tree/master/Introduction)\n\n"}]