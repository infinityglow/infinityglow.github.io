[{"title":"基本数据结构","url":"/study/algorithm/basic-knowledge/data-structure/","content":"\n## 概念\n\n如果说程序员是用代码编织这个世界的一群人，那么**数据结构**（**data structure**）就是编织所用到的各种工具了，它将计算机中各种各样的数据组织在一起。而我们的算法就是利用这些现有的工具将它们拼接成风格、功能各不相同的程序了。简单来说：算法 + 数据结构 = 程序。这一节就让我们来了解一些基本的数据结构吧。\n\n## 数组与链表\n\n我们从最简单的一维数据结构开始。数组大家应该都不陌生，它是将一组相同数据类型的数据存储在一起的数据结构。\n\n![数组](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/array0.png)\n\n这里我们分析一下最基本的三大操作：查找、插入和删除。\n\n拿上面的图为例，因为数组中每一个**元素**（**element**）都有自己的一个下标，称为**索引**（**index**），它们被存储在计算机的RAM中，所以查找的速度非常快。一般查找的时间不随数组长度而增加。\n\n插入和删除就要稍微麻烦一些。因为数组占用的是计算机内存的连续地址空间，所以在插入一个新元素时，所有在它后面的元素都要向后移动一个单位，为新元素“腾出”位置。同理，为了保持数组的完整性，删除一个元素后，所有在它后面的元素也要向前移动一个单位，以此来“填充”空位。\n\n以这里的数组为例，如果我们要删除 `index = 5` 的元素，那么在它后面的 `15`，`34` 和 `80` 都要向前移动一个单位，如下图中所示。\n\n![数组](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/array1.png)\n\n让我们用Python代码来实现一下。\n\n```\n# 查找\ndef search(array, element):\n    length = len(array)\n    for i in range(length):\n        if array[i] == element:\n            return i\n    return -1\n\n# 插入\ndef insert(array, idx, element):\n    new_array = array.copy() + [None]  # 复制原数组到一个新数组\n    length = len(new_array); i = length - 1\n    # 所有idx之后的元素向右移动一个单位\n    while i > idx:\n        new_array[i] = new_array[i-1]\n        i -= 1\n    new_array[idx] = element\n    return new_array\n\n# 删除\ndef remove(array, element):\n    length = len(array)\n    idx = search(array, element)  # 找到对应索引\n    if idx != -1:\n        # 如果查找成功，所有在idx之前的元素向左移动一个单位\n        while idx < length - 1:\n            array[idx] = array[idx+1]\n            idx += 1\n        array = array[: -1]\n    return array\n```\n\n再来说一说链表。与数组采取的顺序存储方式不同，链表中所有的元素的存储地址都是分散的，也就是说，它是靠一条链条（指针）把这些元素联系在一起的。所以我们把链表中每一个存储单元称为一个**节点**（**node**），在每个节点里有两个域：一个用来存储数据，一个是指针指向下一个节点，像这样：\n\n![链表](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/linked-list0.png)\n\n在Python中我们用一个类来表示：\n\n```\nclass Node(object):\n    def __init__ (self, value, next):\n        self.value = value\n        self.next = None\n```\n\n如果将它们串联在一起，将会是这样：\n\n![链表](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/linked-list1.png)\n\n其中的`header`指的是头结点，它一般记录第一个节点的地址和链表的长度，我们在查找的时候就是从头结点开始的，代码如下：\n\n```\nclass Linked_List(object):\n    def __init__ (self):\n        self.length = 0\n        self.header = None\n    def search(self, value):\n        p = self.header  # 获取第一个节点\n        while p != None:\n            if p.value == value:\n                return p\n            p = p.next\n        return None\n```\n\n和数组相比，链表的插入和删除就非常的简单，只需要改变一下指针即可。下面还是以插入元素`61`为例：\n\n首先需要新建一个节点p\n\n![链表](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/linked-list2.png)\n\n然后，p的指针指向头结点所指的节点\n\n![链表](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/linked-list3.png)\n \n最后，改变头结点的指针，使其指向p，同时更新链表的长度length。\n\n![链表](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/linked-list4.png)\n\n插入和删除的Python实现：\n\n```\nclass Linked_List(object):\n    def __init__ (self):\n        self.length = 0\n        self.header = None\n    def insert(self, value):\n        # 新建一个节点\n        p = Node(value)\n        p.next = self.header\n        self.header = p\n        self.length += 1\n    def remove(self):\n        p = self.header  # 获取第一个节点\n        if p is not None:\n            self.header = p.next\n            self.length -= 1\n            del p  # delete node p\n```\n\n##ADT\n\n**抽象数据类型**（**Abstract Data Type**, 简称**ADT**）是数据结构中非常重要的一个部分。用最简单的理解方式就是：不仅限于编程语言中已经实现的一些数据类型，例如 Python 中 List，Set，Tuple，Dictionary 等等。我们可以进一步的定义出属于我们自己数据结构，比如说增删只能在一侧进行，具有层状、环状的结构等等。那就让我们来看看几个最为常见的例子吧～\n\n### 栈\n\n**栈**（**Stack**）就是前面提到的只能在一侧进行元素的增加和删除的数据结构，这种过程分别称为**入栈**(**push**)和**出栈**(**pop**)。生活中最简单的类比就是叠盘子，新洗好的盘子总是放在最上面，而拿走的时候总是从最上面一个拿走。这种后进先出（last in, first out）的方式就体现了这种思想。\n\n![栈](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/stack.jpeg)\n\n### 队列\n\n和栈相反，**队列**（**Queue**）是遵循**先进先出**（**first in, first out**）的方式实现元素的增减，其过程分别叫做**入队**（**enqueue**）和**出队**（**dequeue**）。生活中的例子就是去超市收银台排队的时候，排到队伍后面的人要先等前面的人都结完账了自己才能结账，所以这就是先进先出啦。\n\n![队列](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/queue.png)\n\n因为和前面的数组和链表有相似性，所以这里就不再用Python代码做演示了，你可以去我的[GitHub]()主页查看本节的完整代码。\n\n### 树\n\n与前面的数据结构不同，**树**（**Tree**）是典型的层状数据结构。直观上来看，它就像倒挂着的一颗树，每一个节点连接着多个子节点。这里为了方便，我们只讨论**二叉树**（**Binary Tree**），也就是每一个节点最多只有两个子节点的情况。\n\n![树](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/tree0.png)\n\n下面来简单介绍一下二叉树的性质。和所有树状结构一样，二叉树在非空的情况下一定有一个**根节点**（**root node**），如图中的节点26。它的两个子节点我们分别把它们叫做该节点的**左孩子**（**left child**）和**右孩子**（**right child**），而对于那些没有孩子的节点，我们把它称做**叶子节点**（**leaf node**）。前面只是针对节点的讨论，而对于树本身，我们要了解的是满二叉树和完全二叉树。\n\n满二叉树是指每一个节点孩子的个数只能为0或2，如下图所示，左边是一颗满二叉树，但右边由于节点48只有一个孩子，所以就不是满二叉树。\n\n![树](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/tree1.png)\n\n再来看完全二叉树，它的性质是除了最后一层的节点没有排满以外，其他层的节点均已排满，并且最后一层节点都是从左往右依次排列。下图的两个例子分别代表了完全二叉树和非完全二叉树。后面的[堆](https://infinityglow.github.io/study/algorithm/transform-and-conquer/heap/)\n\n![树](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/tree2.png)\n\n在Python中我们可以用一个类来表示树的节点：\n\n```\nclass Node(object):\n    def __init__ (self, value):\n        self.value = value\n        self.left = None  # 左孩子\n        self.right = None  # 右孩子\n```\n\n### 图\n\n**图**（**Graph**）是 ADT 中用到的最多的结构，生活中的方方面面都会用到图。例如，高德地图就是把所有城市，所有道路通通抽象成了图这种数据结构来帮助我们导航的。哈哈，厉害吧！那我们就首先来了解一下图的基本结构。\n\n图也是由一个一个的**节点**（**vertex**）组成的。但与树不同的是，图的节点之间相连的叫做**边**（**edge**），所以我们用 G = <V, E> 来表示一张图，其中的 V 表示由 vertex 构成的集合，而 E 则表示由 edge 构成的集合。\n\n图的分类一般有好几种，如果一个节点到另一个节点是双向的我们把它叫做**无向图**（**undirected graph**），如果是单向的就叫**有向图**（**undirected graph**），下图中就分别代表了无向图和有向图。\n\n![图](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/graph0.png)\n\n假如从一个节点到另一个节点是要付出“代价”的，那么我们就可以在每一条边上把这种“代价”体现出来，称之为**权重**（**weight**），而构成这样的图当然就叫做**有权图**（**weighted graph**）了。\n\n![图](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/graph1.png)\n\n我们可以用两种方式来表示一张图，一种叫做**邻接矩阵**（**adjacency matrix**）和**邻接表**（**adjacency list**），后面的内容会详细讨论，先上图。\n\n![图](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/graph2.png)\n\n这样我们就完成所有基本数据结构的学习了，是不是对它们有了清晰的认识呢？\n\n[本节全部代码](https://github.com/infinityglow/Algorithm-and-Complexity/tree/master/Basic%20Knowledge/Data%20Structure)\n"},{"title":"算法与复杂度","url":"/study/algorithm/overview/","content":"\n## 前言\n\n这个系列的博文会逐个介绍计算机科学里面最基础、也是最重要的一部分内容：算法(algorithm)。提到它，这可能是你最擅长的部分，亦或是你学生生涯的噩梦。不管怎么样，对于学计算机的小伙伴来讲，它始终是不可回避的一个话题。不论是学生时代的你还是已经踏上了工作的岗位，算法都会一直陪伴着你。\n\n为什么要做这个系列呢？因为网上对于这一块的内容实在是太多，甚至是太杂，而很少有把算法的知识体系整合起来形成一个系列的教学博客。于是乎想尽自己的微薄之力，让更多的人能够更好地理解算法，在未来求职的面试中不再因为它而与自己理想的公司失之交臂。\n\n我将与国内的教学方式和教学内容有所差别。形式上不再是只针对如何解决这个问题，因为只会解决问题并不代表真正理解这个问题。我会花一些篇幅着重介绍一些概念性的内容，这也是国内的教学最欠缺的部分。国内的课堂不会告诉你自然对数e与自然界生长的规律有关；学完了线性代数，你可能光学会了如何解行列式，却忽视了行列式也是有几何意义的。内容上不再按照“排序算法”、“搜索算法”等方式分类，而采用了问题解决的不同方式来划分，比如“暴力求解”、“分治法”、“动态规划”等等。当然，我也是参考了Levitin编写的教材[Introduction to The Design and Analysis of Algorithms, 3rd Edition](https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/Introduction%20to%20the%20Design%20and%20Analysis%20of%20Algorithms%20%283rd%20ed.%29%20%5BLevitin%202011-10-09%5D.pdf)。要是你觉得这本书讲得太基础，你也可以参考MIT的[《算法导论》](http://kddlab.zjgsu.edu.cn:7200/students/lipengcheng/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%88%E8%8B%B1%E6%96%87%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89.pdf)。\n\n编程语言我会采用Python，因为Python是最接近这些英文书里用于讲解的伪代码，理解起来会更加方便。对于刚入门的小白来讲，Python的简洁不会让你因为不能理解编程语言本身而最终放弃了这门课程的学习。我会把每一节的内容的完整代码都放在我的GitHub的Algorithm仓库里，方便学习后用代码真正实现它们。\n\n最后，要是讲解有任何疑问，欢迎在评论区留言。如果发现了有任何错误和表述不规范的地方，希望各位大佬轻喷，毕竟我也是第一次写博客，有错误也是在所难免的。\n\n## 总览\n\n### 介绍 (Introduction)\n\n&emsp;[1.1 什么是算法](https://infinityglow.github.io/study/algorithm/introduction/)\n\n### 基本知识 (Basic Knowledge)\n\n&emsp;[2.1 基本数据结构](https://infinityglow.github.io/study/algorithm/basic-knowledge/data-structure/)\n&emsp;[2.2 算法的问题类型](https://infinityglow.github.io/study/algorithm/basic-knowledge/problem-types/)\n\n### 复杂度分析 (Complexity Analysis)\n\n&emsp;[3.1 三种表示方法：O, Ω, Θ](https://infinityglow.github.io/study/algorithm/complexity-analysis/three-notations/)\n&emsp;[3.2 复杂度分析（非递归）](https://infinityglow.github.io/study/algorithm/complexity-analysis/non-recursive/)\n&emsp;[3.3 复杂度分析（递归）](https://infinityglow.github.io/study/algorithm/complexity-analysis/recursive/)\n\n### 暴力求解 (Brute Force)\n\n&emsp;[4.1 冒泡排序与选择排序](https://infinityglow.github.io/study/algorithm/brute-force/bubble-selection-sort/)\n&emsp;[4.2 顺序查找与字符串匹配（BF）](https://infinityglow.github.io/study/algorithm/brute-force/string-matching/)\n&emsp;[4.3 图的两种遍历](https://infinityglow.github.io/study/algorithm/brute-force/graph-traversal/)\n&emsp;[4.4 最近点对与凸包问题（BF）](https://infinityglow.github.io/study/algorithm/brute-force/clo-pair-con-hull/)\n&emsp;[4.5 暴力搜索](https://infinityglow.github.io/study/algorithm/brute-force/exhaustive-search/)\n\n### 减治法（Decrease and Conquer）\n\n&emsp;[5.1 插入排序](https://infinityglow.github.io/study/algorithm/decrease-and-conquer/insertion-sort/)\n&emsp;[5.2 拓扑排序](https://infinityglow.github.io/study/algorithm/decrease-and-conquer/topo-sorting/)\n&emsp;[5.3 二分查找与二叉树](https://infinityglow.github.io/study/algorithm/decrease-and-conquer/binary-search-tree/)\n&emsp;[5.4 插值查找](https://infinityglow.github.io/study/algorithm/decrease-and-conquer/interpolation-search/)\n\n### 分治法（Divide and Conquer）\n\n&emsp;[6.1 归并排序](https://infinityglow.github.io/study/algorithm/divide-and-conquer/merge-sort/)\n&emsp;[6.2 快速排序](https://infinityglow.github.io/study/algorithm/divide-and-conquer/quick-sort/)\n&emsp;[6.3 二叉树的遍历](https://infinityglow.github.io/study/algorithm/divide-and-conquer/bt-traversal/)\n&emsp;[6.4 最近点对与凸包问题（DC）](https://infinityglow.github.io/study/algorithm/divide-and-conquer/clo-pair-con-hull/)\n\n### 变治法（Transform and Conquer）\n\n&emsp;[7.1 预排序](https://infinityglow.github.io/study/algorithm/transform-and-conquer/presorting/)\n&emsp;[7.2 霍纳法则](https://infinityglow.github.io/study/algorithm/transform-and-conquer/horners-rule/)\n&emsp;[7.3 堆与堆排序](https://infinityglow.github.io/study/algorithm/transform-and-conquer/heap/)\n&emsp;[7.4 AVL树](https://infinityglow.github.io/study/algorithm/transform-and-conquer/AVL-tree/)\n&emsp;[7.5 红黑树](https://infinityglow.github.io/study/algorithm/transform-and-conquer/R&B-tree/)\n&emsp;[7.6 2-3树](https://infinityglow.github.io/study/algorithm/transform-and-conquer/two-three-tree/)\n\n### 时空权衡（Time Space Tradeoff）\n\n&emsp;[8.1 计数排序](https://infinityglow.github.io/study/algorithm/time-space-tradeoff/counting-sort/)\n&emsp;[8.2 字符串匹配（TST）](https://infinityglow.github.io/study/algorithm/time-space-tradeoff/string-matching/)\n&emsp;[8.3 哈希](https://infinityglow.github.io/study/algorithm/time-space-tradeoff/hashing/)\n\n### 动态规划（Dynamic Programming）\n\n&emsp;[9.1 关于钱的两个经典问题](https://infinityglow.github.io/study/algorithm/dynamic-programming/classic-problems/)\n&emsp;[9.2 背包问题（DP）](https://infinityglow.github.io/study/algorithm/dynamic-programming/knapsack-problem/)\n&emsp;[9.3 弗洛伊德算法](https://infinityglow.github.io/study/algorithm/dynamic-programming/Floyd-Warshall/)\n  \n### 贪心算法（Greedy Algorithm）\n\n&emsp;[10.1 普林姆算法](https://infinityglow.github.io/study/algorithm/greedy-algorithm/Prim/)\n&emsp;[10.2 克鲁斯卡尔算法](https://infinityglow.github.io/study/algorithm/greedy-algorithm/Kruskal/)\n&emsp;[10.3 迪克斯特拉算法](https://infinityglow.github.io/study/algorithm/greedy-algorithm/Dijkstra/)\n&emsp;[10.4 哈弗曼树](https://infinityglow.github.io/study/algorithm/greedy-algorithm/Huffman-tree/)\n\n### *高阶算法（Advanced Algorithm）\n\n&emsp;[*回溯](https://infinityglow.github.io/study/algorithm/advanced-algorithm/backtracking/)\n&emsp;[*分支限界](https://infinityglow.github.io/study/algorithm/advanced-algorithm/branch-and-bound/)\n&emsp;[*线性规划（单纯形法）](https://infinityglow.github.io/study/algorithm/advanced-algorithm/linear-programming/)\n&emsp;[*最大流问题](https://infinityglow.github.io/study/algorithm/advanced-algorithm/maximum-flow/)\n&emsp;[*匈牙利算法](https://infinityglow.github.io/study/algorithm/advanced-algorithm/hungarian-algorithm/)\n&emsp;[*千禧问题：P = NP ?](https://infinityglow.github.io/study/algorithm/advanced-algorithm/p-np/)\n\n"},{"title":"手把手教你用VPS搭建SS+bbr实现科学上网","url":"/others/ss_v2ray/ss/","content":"\n## 写在前面\n\n  首先先声明一下，本文不带有任何商业性质，单纯地是想方便海内外学生党使用Google、YouTube、Wikipedia等工具来查阅资料，作为一个Google和Wikipedia的重度使用者，有时候离开了这两样东西真的就没办法生活，所以做一个这方面的教程是非常有必要的。\n\n  如果你对访问外网的频率和带宽要求不高，用一般的免费vpn或者一些在线代理就足够了，市面上这些vpn哪个好用，哪个免费相信你们比我更清楚。如果要经常看YouTube高清视频或者连外服打游戏的小伙伴呢，这些免费但又不稳定的vpn自然就不能满足你们的需要了，所以得拥有一个自己专属的服务器来实现科学上网。\n\n## 基本原理\n\n![Shadowsocks基本原理](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/principle.png \"基本原理示意图\")\n\n  简单介绍一下ss的基本原理，其实ss就是隧道通信的一种，就是说从中国大陆直接访问Google、Facebook等黑名单网站是会被防火墙检测到并直接中断我们与这些服务器的连接的。这时候ss横空出世，作为一个中间者把我们将要发送给Google、Facebook服务器的请求经过本地(sslocal)加密，再将它们封装一下，与我们后面要部署的服务器达成通信协议。\n\n  当服务器(ssserver)端收到来自sslocal的数据之后，先解密，再将解密过后的数据发送给Google、Facebook服务器。当这些服务器把数据传回给ssserver过后，ssserver会将这些数据加密并打包发送给sslocal，sslocal拿到数据之后再进行解密，最后以网页的形式呈现出来。整个过程中，由于数据是进行加密的，所以防火墙是不知道我们在访问Google等外网的。\n\n  但据说最近ss已经能够被防火墙识别出来其特征，安全性存在一些漏洞，如果有空了可以再做一期v2ray的教程，其安全性和稳定性都要比ss要高。\n\n## 部署VPS\n\n  第一步需要部署我们的云服务器，这里先推荐一下[谷歌云](https://cloud.google.com)，可以免费试用一年的时间，并且还比较稳定，但有点麻烦的是需要你绑定信用卡，而且还必须是美国的。。。\n\n  这里我们演示的是一些主流服务商提供的VPS，话不多说，先推荐一波：\n\n  [搬瓦工](https://bandwagonhost.com)\n  [vultr](https://www.vultr.com)\n  [hostwind](https://www.hostwinds.com)\n  [time4vps](https://www.time4vps.com)\n\n  有的可能在国内被墙掉了，访问不了的只能自己想办法了。\n\n  这里以vultr为例，先进入官网。\n\n![vultr官网](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s1.png)\n  如果你是新用户，则需要先注册一下，这里点击“Sign up”。\n  点击之后，用你的邮箱作为用户名，然后自己创建一个密码。\n\n![vultr注册界面](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s2.png)\n  注册完以后登录即可。\n\n![vultr登录界面](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s3.png)\n  进入如下页面之后，选择“Product”，再点击右边的加号部署服务器。\n\n![部署服务器](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s4.png)\n![部署服务器](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s5.png)\n![部署服务器](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s6.png)\n\n  这里我们选择纽约的节点(因为最便宜)，然后系统选择Ubuntu 18.04，服务器配置根据自己的需求来选择。选完以后，点击下方的“Deploy Now”。付完款以后，将会出现如下的界面。\n![成功部署](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s7.png)\n\n## Shadowsocks服务器端配置\n\n  成功部署好VPS后就要开始服务器端的配置了。首先我们进入到服务器的信息页面(如下图所示)，我们需要记住这里的IP地址以及ssh远程登录时的密码。\n![服务器信息](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s10.png)\n\n  拿到IP地址以后可以先打开终端ping一下以确保服务器是否可用。我这里以Ubuntu系统作为演示，通信一切正常。\n![ping](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s9.png)\n\n  下一步就要用ssh命令远程登录我们的服务器了。Mac用户和Linux用户直接在终端使用ssh命令即可，Windows用户呢就要稍微麻烦一点，得先在网上下载PuTTY，然后再远程登录。\n\n``` bash\n$ ssh root@45.77.108.240\n```\n\n  按下回车后会叫你输入密码，也就是前面服务器信息里的密码。登录成功后就会出现下面的界面。\n\n![登录成功](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s12.png)\n\n  成功登录后，为了确保兼容性，需要更新一下软件包。\n\n``` bash\n$ sudo apt update\n$ sudo apt upgrade -y\n```\n\n  安装python和pip\n\n``` bash\n$ sudo apt install python\n$ sudo apt install python-pip\n```\n\n  安装shadowsocks\n\n``` bash\n$ pip install shadowsocks\n```\n  \n  在/etc/目录下创建shadowsocks.json配置文件\n\n``` bash\n$ vim /etc/shadowsocks.json\n```\n  \n  进入到vim界面之后，按i进入插入模式，然后按照下面的模板将服务器的配置信息写好(只需将端口号和密码改成自己想要的即可)，最后按”Esc“+“:wq”保存并退出\n\n```{\n    \"server\":\"0.0.0.0\",\n    \"server_port\": \"YOUR_PORT\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":\"1080\",\n    \"password\":\"YOUR_PASSWD\",\n    \"timeout\":\"500\",\n    \"method\":\"aes-256-cfb\"\n}```\n\n  配置文件写好以后就要启动我们的server了，在这里我们需要从配置文件中读取相应参数，因此ssserver命令需要加入-c参数。\n\n``` bash\n$ ssserver -c /etc/shadowsocks.json\n```\n\n  不出意外的话，第一次启动应该会报出“AttributeError: /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup”这样的错，这篇[博客](https://blog.csdn.net/St_Louis/article/details/103171781)给出了完美的解决方案，只需要修改一个文件中的两行数据就行，这里我就不一一演示了。\n\n  如果想要在后台运行，只需要在最后加入“-d start”即可。\n\n``` bash\n$ ssserver -c /etc/shadowsocks.json -d start\n```\n\n## Shadowsocks客户端配置\n\n  客户端比服务器端就要好配置多啦，三大主流操作系统都支持[图形化界面](https://github.com/shadowsocks/shadowsocks-gui)，Linux甚至支持还命令行的客户端。这里以Linux的GUI为例，只需要把服务器端的IP地址、端口号、密码、加密方式按照你服务器端配置的方式填写正确即可，剩下的本地地址、本地端口、协议类型就按照下面的方式填写就行了。\n\n![客户端配置](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s26.png)\n\n## 浏览器配置\n\n  虽然我们的服务器端和客户端都已经配置好了，但要在浏览器里实现外网的访问还需要几个简单的步骤。\n\n  首先需要在[chrome网上应用店](https://chrome.google.com/webstore/category/extensions?hl=zh-CN)下载一个叫做SwitchyOmega的插件。下载完成后在你的浏览器右上方会有一个小圆圈，点击后选择Option。\n![插件](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s15.png)\n\n  进入后选择左边的proxy，Protocol选择Socks5，Sever选择127.0.0.1，Port为1080。\n![Proxy](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s16.png)\n\n  保存退出后，就能访问Google啦～\n\n  但这样有一个问题，所有的流量都走了代理服务器，而平时我们访问一些国内的网站是不需要走代理的，并且用代理服务器来访问国内的网站会非常的慢。可不可以实现自动分流呢？哈哈，SwitchyOmega给我们了这样一个“贴心”的服务：auto switch\n\n  选择左边的auto switch，再选择“Add a rule list”\n\n![auto switch](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s17.png)\n\n  在\"Rule list rules\"选择\"proxy，Rule List Format\"选择\"AutoProxy\"\n\n![auto switch](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s21.png)\n\n  我们可以自定义规则，哪些网址走代理，哪些直接访问。但这样一个一个输入实在太麻烦，我们直接从GitHub上搜索gfwlist即可。\n\n  选择第一项\n![github gfwlist](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s18.png)\n\n  进入后点击gfwlist.txt，复制URL到SwitchyOmega中的Rule List URL，再点击Download Profile Now\n![auto switch](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s19.png)\n\n  更改应用后，你会发现下方的Rule List Text出现了各种网址，这说明已经添加成功了。\n![auto switch](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s23.png)\n\n  这样当我们把SwitchyOmega的模式选择成auto switch后就能实现智能分流啦。\n\n## bbr加速\n\n  最后，为了让我们的网速飞起来，看YouTube视频不会卡顿，需要借助一个叫做bbr加速的东西。操作非常简单，只需要几个步骤就好。这里需要再次登录我们的VPS，在VPS里进行操作。\n\n  修改系统变量并保存\n``` bash\n$ echo \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\n$ echo \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\n$ sysctl -p\n\n```\n\n  查看是否开启\n``` bash\n$ sysctl net.ipv4.tcp_available_congestion_control\n```\n\n  如果显示如下内容表示已经开启\n``` bash\n$ net.ipv4.tcp_available_congestion_control = reno cubic bbr\n```\n\n  查看BBR是否启动\n``` bash\n$ lsmod | grep bbr\n```\n\n  如果显示以下内容表示已经开启\n``` bash\n$ tcp_bbr                20480  25\n```\n\n  开启了bbr加速以后网速快的飞起，以我家的100M带宽为例，看YouTube 4k视频一点都不卡顿，网速也是相当给力的。\n![YouTube](https://infinityglow.github.io/others/ss_v2ray/screenshot_ss/s25.png)\n\n"},{"title":"什么是算法","url":"/study/algorithm/introduction/","content":"\n## 概念\n\n什么是算法？英文维基百科给出了这样的定义：“An algorithm is a finite sequence of well-defined, computer-implementable instructions, typically to solve a class of problems or to perform a computation.”翻译过来的意思就是一系列有限的、清晰定义的、可实现的计算机指令，并用以解决一类问题或进行计算。\n\n是不是被这么官方的定义搞懵了？在生活中一个最简单的类比就是烹饪。如果把要烧一道菜比作这里要解决的问题，那么菜谱中每一道工序，每一个步骤就是这道菜的“算法”了。但这样的类比也存在一些问题：我们的算法要求每一步都是要明确定义，也就是说不能有任何歧义的。还是拿做菜来讲，如果菜谱上是这样定义的：\n\n- 将油倒入锅中加热至七成热\n- 把鸡腿放入油锅中炸至金黄\n- 放入少许盐\n\n![炸鸡腿](https://infinityglow.github.io/study/algorithm/introduction/images/chicken-leg.jpg)\n\n以上的步骤虽然前后有逻辑性，最终能够做出炸鸡腿，但是这样的定义是不符合算法的规范的，因为这样的定义只具备了**经验性**（**empirical**），不具备**系统性**（**systematical**），计算机是读不懂人类的这些经验的。所以，正确的姿势应该是这样的：\n\n- 将200ml的色拉油放入铁锅中，打开电炉，调至第9档，当油温达到200°C后停止加热\n- 把碗里的鸡腿依次放入油锅中煎炸，直至鸡腿表面呈现出 #FF9900 (金黄色RGB的十六进制表示法)\n- 根据鸡腿的重量（g）和一个映射函数 f(x) 计算出需要放置的盐的重量（g），将其放入锅中\n\n这样我们的计算机就好理解多啦～\n\n![happy](https://infinityglow.github.io/study/algorithm/introduction/images/happy.jpg)\n\n## 解决的问题\n\n了解完了算法的概念，那么算法是要用来干什么的呢？前面提到了是用来解决一类问题，这样的问题可以是[排序](https://infinityglow.github.io/tags/sorting/), [查找](https://infinityglow.github.io/tags/search/)，最优化问题等等。总之，这些问题大部分都是有确定解的，我们只需要用其中的一种算法找到它们即可。\n\n但是，仅仅找到了算法来解决这些问题是远远不够的。我们还需要考虑这个算法的效率如何，也就是对其进行[复杂度](https://infinityglow.github.io/study/algorithm/complexity-analysis/three-notations)分析。这里暂时不做讨论，先举一个经典的算法问题：扔鸡蛋问题。假设楼高为100层，给你2个鸡蛋，你需要试出来从第几层往下扔鸡蛋刚好会碎。你可能首先想到的是从第一层开始一层一层地扔直到鸡蛋摔碎，但是这样你可能最多扔99次（假设从100层往下扔鸡蛋才碎），而且你没有利用上第二个鸡蛋。一些聪明的同学可能又想到了用一个鸡蛋十层十层地往上扔，如果碎了就在两个十层之间一层一层地往上扔。这样最多只要扔19次，已经比之前的方法有了明显的进步，这就是算法要考虑的效率问题。事实上，这个问题的最优解是最多扔14次，需要后面要讲到的[动态规划](https://infinityglow.github.io/tag/dp/)。\n\n![扔鸡蛋](https://infinityglow.github.io/study/algorithm/introduction/images/egg.png)\n\n## 例子\n\n让我们看一道完整的例子，求两个数的最大公约数。相信在中学阶段老师就告诉过你们把两个数的因子提取出来，然后把所有共同的因子相乘得到结果。这里我们对这种方法不做讨论，让我们先看看一种高效的解法：**欧几里得算法**（**Euclid's Algorithm**）。\n\n欧几里得算法又叫辗转取余法，其原理是两个数的最大公约数等于较小数与两数取余的最大公约数，用数学语言来描述的话就是 `gcd(m, n) = gcd(n, m mod n)`。但这只是其中的一步，什么时候才返回我们想要的结果呢？这就需要用算法语言来描述这个过程，这种语言可以是自然语言，也可以是数学语言（伪代码）。让我们先以自然语言为例吧。\n\n- 第一步：如果 n = 0，返回m；否则执行第二步。\n- 第二步：m 除以 n，将余数赋给变量r。\n- 第三步：把 n 赋给 m，r 赋给 n。执行第一步。\n\n如果用伪代码来表示的话就是这样的：\n\n![伪代码](https://infinityglow.github.io/study/algorithm/introduction/images/Euclid.png)\n\n最后，让我们用Python来实现这个函数吧。\n\n```\ndef gcd(m, n):\n    while n != 0:\n        r = m\n        m = n\n        n = r % n\n        gcd(m, n)\n    return m\n```\n\n[本节全部代码](https://github.com/infinityglow/Algorithm-and-Complexity/tree/master/Introduction)\n\n"}]